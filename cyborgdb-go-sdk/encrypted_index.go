/*
CyborgDB API

CyborgDB is a secure, encrypted vector database that allows you to store and query high-dimensional vectors with end-to-end encryption. This OpenAPI specification describes the REST interface used by the Go SDK client to perform operations such as indexing, querying, and health checks. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cyborgdb

import (
	"context"
	"encoding/json"
	"fmt"
)

// checks if the EncryptedIndex type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &EncryptedIndex{}

// EncryptedIndex struct for EncryptedIndex
type EncryptedIndex struct {
	IndexName *string      `json:"index_name,omitempty"`
	IndexKey  string       `json:"-"` // Don't serialize the key for security
	IndexType *string      `json:"index_type,omitempty"`
	Config    *IndexConfig `json:"config,omitempty"`
	client    *Client      `json:"-"` // Don't serialize the client
}

// NewEncryptedIndex instantiates a new EncryptedIndex object
func NewEncryptedIndex() *EncryptedIndex {
	this := EncryptedIndex{}
	return &this
}

// NewEncryptedIndexWithDefaults instantiates a new EncryptedIndex object
func NewEncryptedIndexWithDefaults() *EncryptedIndex {
	this := EncryptedIndex{}
	return &this
}

// GetIndexName returns the IndexName field value if set, zero value otherwise.
func (o *EncryptedIndex) GetIndexName() string {
	if o == nil || IsNil(o.IndexName) {
		var ret string
		return ret
	}
	return *o.IndexName
}

// GetIndexNameOk returns a tuple with the IndexName field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EncryptedIndex) GetIndexNameOk() (*string, bool) {
	if o == nil || IsNil(o.IndexName) {
		return nil, false
	}
	return o.IndexName, true
}

// HasIndexName returns a boolean if a field has been set.
func (o *EncryptedIndex) HasIndexName() bool {
	if o != nil && !IsNil(o.IndexName) {
		return true
	}
	return false
}

// SetIndexName gets a reference to the given string and assigns it to the IndexName field.
func (o *EncryptedIndex) SetIndexName(v string) {
	o.IndexName = &v
}

// GetIndexType returns the IndexType field value if set, zero value otherwise.
func (o *EncryptedIndex) GetIndexType() string {
	if o == nil || IsNil(o.IndexType) {
		var ret string
		return ret
	}
	return *o.IndexType
}

// GetIndexTypeOk returns a tuple with the IndexType field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EncryptedIndex) GetIndexTypeOk() (*string, bool) {
	if o == nil || IsNil(o.IndexType) {
		return nil, false
	}
	return o.IndexType, true
}

// HasIndexType returns a boolean if a field has been set.
func (o *EncryptedIndex) HasIndexType() bool {
	if o != nil && !IsNil(o.IndexType) {
		return true
	}
	return false
}

// SetIndexType gets a reference to the given string and assigns it to the IndexType field.
func (o *EncryptedIndex) SetIndexType(v string) {
	o.IndexType = &v
}

// GetConfig returns the Config field value if set, zero value otherwise.
func (o *EncryptedIndex) GetConfig() IndexConfig {
	if o == nil || IsNil(o.Config) {
		var ret IndexConfig
		return ret
	}
	return *o.Config
}

// GetConfigOk returns a tuple with the Config field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EncryptedIndex) GetConfigOk() (*IndexConfig, bool) {
	if o == nil || IsNil(o.Config) {
		return nil, false
	}
	return o.Config, true
}

// HasConfig returns a boolean if a field has been set.
func (o *EncryptedIndex) HasConfig() bool {
	if o != nil && !IsNil(o.Config) {
		return true
	}
	return false
}

// SetConfig gets a reference to the given IndexConfig and assigns it to the Config field.
func (o *EncryptedIndex) SetConfig(v IndexConfig) {
	o.Config = &v
}

func (o EncryptedIndex) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o EncryptedIndex) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.IndexName) {
		toSerialize["index_name"] = o.IndexName
	}
	if !IsNil(o.IndexType) {
		toSerialize["index_type"] = o.IndexType
	}
	if !IsNil(o.Config) {
		toSerialize["config"] = o.Config
	}
	return toSerialize, nil
}

type NullableEncryptedIndex struct {
	value *EncryptedIndex
	isSet bool
}

func (v NullableEncryptedIndex) Get() *EncryptedIndex {
	return v.value
}

func (v *NullableEncryptedIndex) Set(val *EncryptedIndex) {
	v.value = val
	v.isSet = true
}

func (v NullableEncryptedIndex) IsSet() bool {
	return v.isSet
}

func (v *NullableEncryptedIndex) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEncryptedIndex(val *EncryptedIndex) *NullableEncryptedIndex {
	return &NullableEncryptedIndex{value: val, isSet: true}
}

func (v NullableEncryptedIndex) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEncryptedIndex) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

// ============================================================================
// METHODS
// ============================================================================

// Upsert adds or updates vectors in the index
func (e *EncryptedIndex) Upsert(ctx context.Context, items []VectorItem) error {
	if e.client == nil {
		return fmt.Errorf("cannot upsert vectors: client reference is nil")
	}
	if e.IndexName == nil || *e.IndexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.IndexKey == "" {
		return fmt.Errorf("index key is required")
	}

	// Map user-facing VectorItems to API VectorItems
	apiItems := make([]VectorItem, len(items))
	for i, item := range items {
		apiItem := VectorItem{
			Id:       item.Id,
			Vector:   item.Vector,
			Metadata: item.Metadata,
		}
		if item.Contents != nil {
			apiItem.Contents = item.Contents
		}
		apiItems[i] = apiItem
	}

	// Construct request with ALL required fields
	upsertRequest := UpsertRequest{
		IndexKey:  e.IndexKey,
		IndexName: *e.IndexName,
		Items:     apiItems,
	}

	// Call with XIndexKey header (keeping for compatibility with current API client)
	_, err := e.client.apiClient.DefaultAPI.
		UpsertVectors(ctx, *e.IndexName).
		XIndexKey(e.IndexKey).
		UpsertRequest(upsertRequest).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to upsert vectors: %w", err)
	}
	return nil
}

// DeleteIndex deletes the current encrypted index from the CyborgDB service.
func (e *EncryptedIndex) DeleteIndex(ctx context.Context) error {
	if e.client == nil {
		return fmt.Errorf("cannot delete index: client reference is nil")
	}
	if e.IndexName == nil || *e.IndexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.IndexKey == "" {
		return fmt.Errorf("index key is required")
	}
	if len(e.IndexKey) != 64 {
		return fmt.Errorf("index key must be 64-character hex string (32 bytes), got %d", len(e.IndexKey))
	}

	// Call the low-level API
	_, err := e.client.apiClient.DefaultAPI.
		DeleteIndex(ctx, *e.IndexName).
		XIndexKey(e.IndexKey).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to delete index '%s': %w", *e.IndexName, err)
	}

	return nil
}

// Train trains the encrypted index using the specified parameters.
func (e *EncryptedIndex) Train(ctx context.Context, batchSize int32, maxIters int32, tolerance float64) error {
	if e.client == nil {
		return fmt.Errorf("cannot train index: client reference is nil")
	}
	if e.IndexName == nil || *e.IndexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.IndexKey == "" {
		return fmt.Errorf("index key is required")
	}
	if len(e.IndexKey) != 64 {
		return fmt.Errorf("index key must be 64-character hex string (32 bytes), got %d", len(e.IndexKey))
	}

	// Prepare the train request
	trainReq := TrainRequest{
		IndexName: *e.IndexName,
		IndexKey:  e.IndexKey,
		BatchSize: &batchSize,
		MaxIters:  &maxIters,
		Tolerance: &tolerance,
	}

	// Call the low-level API
	_, err := e.client.apiClient.DefaultAPI.
		TrainIndex(ctx, *e.IndexName).
		XIndexKey(e.IndexKey).
		TrainRequest(trainReq).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to train index '%s': %w", *e.IndexName, err)
	}

	return nil
}

// Query searches for nearest neighbors in the index
func (e *EncryptedIndex) Query(ctx context.Context, queryVectors interface{}, topK int32, nProbes int32, greedy bool, filters map[string]interface{}, include []string) (*QueryResponse, error) {
	if e.client == nil {
		return nil, fmt.Errorf("cannot query index: client reference is nil")
	}
	if e.IndexName == nil || *e.IndexName == "" {
		return nil, fmt.Errorf("index name is required")
	}
	if e.IndexKey == "" {
		return nil, fmt.Errorf("index key is required")
	}

	// Handle single vector vs batch of vectors
	var vectors [][]float32
	switch v := queryVectors.(type) {
	case []float32:
		// Single vector - wrap in array
		vectors = [][]float32{v}
	case [][]float32:
		// Batch of vectors
		vectors = v
	default:
		return nil, fmt.Errorf("queryVectors must be []float32 or [][]float32")
	}

	// Set defaults if needed
	if topK == 0 {
		topK = 100
	}
	if nProbes == 0 {
		nProbes = 1
	}
	if include == nil || len(include) == 0 {
		include = []string{"distance", "metadata"}
	}

	// Create the query request
	queryRequest := QueryRequest{
		IndexName:    *e.IndexName,
		IndexKey:     e.IndexKey,
		QueryVectors: vectors,
		TopK:         topK,
		NProbes:      nProbes,
		Greedy:       &greedy,
		Filters:      filters,
		Include:      include,
	}

	// Execute the query
	resp, _, err := e.client.apiClient.DefaultAPI.
		QueryVectors(ctx).
		QueryRequest(queryRequest).
		Execute()

	if err != nil {
		return nil, fmt.Errorf("failed to query index '%s': %w", *e.IndexName, err)
	}

	return resp, nil
}

// Delete removes vectors from the encrypted index by their IDs.
func (e *EncryptedIndex) Delete(ctx context.Context, ids []string) error {
	if e.client == nil {
		return fmt.Errorf("cannot delete vectors: client reference is nil")
	}
	if e.IndexName == nil || *e.IndexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.IndexKey == "" {
		return fmt.Errorf("index key is required")
	}
	if len(e.IndexKey) != 64 {
		return fmt.Errorf("index key must be 64-character hex string (32 bytes), got %d", len(e.IndexKey))
	}
	if len(ids) == 0 {
		return fmt.Errorf("at least one vector ID must be provided for deletion")
	}

	// Construct the delete request body
	deleteReq := DeleteRequest{
		IndexName: *e.IndexName,
		IndexKey:  e.IndexKey,
		Ids:       ids,
	}

	// Call the low-level API
	_, err := e.client.apiClient.DefaultAPI.
		DeleteVectors(ctx, *e.IndexName).
		XIndexKey(e.IndexKey).
		DeleteRequest(deleteReq).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to delete vectors from index '%s': %w", *e.IndexName, err)
	}

	return nil
}

// Get retrieves vectors from the index by their IDs.
func (e *EncryptedIndex) Get(ctx context.Context, ids []string, include []string) ([]VectorItem, error) {
	if e.client == nil {
		return nil, fmt.Errorf("cannot get vectors: client reference is nil")
	}
	if e.IndexName == nil || *e.IndexName == "" {
		return nil, fmt.Errorf("index name is required")
	}
	if e.IndexKey == "" {
		return nil, fmt.Errorf("index key is required")
	}
	if len(ids) == 0 {
		return nil, fmt.Errorf("at least one vector ID must be provided for retrieval")
	}

	// Prepare the API request
	resp, _, err := e.client.apiClient.DefaultAPI.
		GetVectors(ctx, *e.IndexName).
		XIndexKey(e.IndexKey).
		Ids(ids).
		Include(include).
		Execute()

	if err != nil {
		return nil, fmt.Errorf("failed to retrieve vectors from index '%s': %w", *e.IndexName, err)
	}

	return resp, nil
}