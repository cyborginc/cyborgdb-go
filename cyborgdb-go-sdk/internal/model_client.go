package internal

import (
	"context"
	"crypto/tls"
	"encoding/hex"
	"fmt"
	"net/http"
	"net/url"
)

// Client provides a high-level interface to the CyborgDB API.
//
// This struct wraps the generated low-level API client (`*APIClient`) and
// exposes user-friendly methods like CreateIndex, ListIndexes, and GetHealth.
// It also holds client-wide settings such as the base URL and API key.
type Client struct {
	apiClient *APIClient // The autogenerated low-level API client (OpenAPI-based)
	baseURL   string     // The root URL for CyborgDB (e.g., https://api.cyborgdb.com)
	apiKey    string     // API key used for authentication in HTTP headers
}

// NewClient creates and configures a new instance of the CyborgDB Client.
//
// Parameters:
//   - baseURL: The base endpoint for the CyborgDB API (e.g., "https://api.cyborgdb.com").
//   - apiKey: The API key used for authentication. This will be sent in the `X-API-Key` header.
//   - verifySSL: If false, disables SSL certificate verification (e.g., for local dev with self-signed certs).
//
// Returns:
//   - A pointer to an initialized `Client` instance.
//   - An error if the baseURL is invalid or the client fails to initialize properly.
func NewClient(baseURL, apiKey string, verifySSL bool) (*Client, error) {
	// Parse the baseURL string into a structured URL type.
	parsedURL, err := url.Parse(baseURL)
	if err != nil {
		return nil, fmt.Errorf("invalid base URL: %w", err)
	}

	// Print a development-mode warning if SSL verification is disabled on localhost.
	if !verifySSL && (parsedURL.Hostname() == "localhost" || parsedURL.Hostname() == "127.0.0.1") {
		fmt.Println("SSL verification is disabled for localhost (development mode)")
	}

	// Create a new configuration for the low-level API client.
	cfg := NewConfiguration()
	cfg.Scheme = parsedURL.Scheme
	cfg.Host = parsedURL.Host

	// Override the server URL list with one that includes a /v1 suffix.
	cfg.Servers = []ServerConfiguration{
		{
			URL:         fmt.Sprintf("%s://%s/v1", parsedURL.Scheme, parsedURL.Host),
			Description: "CyborgDB API with /v1",
		},
	}

	// Set the API key in the client's default headers, if provided.
	if apiKey != "" {
		cfg.AddDefaultHeader("X-API-Key", apiKey)
	}

	// Configure the HTTP client to skip certificate verification if verifySSL is false.
	// This is useful for local dev or CI environments with self-signed certificates.
	cfg.HTTPClient = &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: !verifySSL},
		},
	}

	// Instantiate the low-level OpenAPI-generated API client with the custom config.
	apiClient := NewAPIClient(cfg)

	// Return a pointer to the high-level Client wrapper, which exposes ergonomic methods.
	return &Client{
		apiClient: apiClient,
		baseURL:   baseURL,
		apiKey:    apiKey,
	}, nil
}
// ListIndexes retrieves a list of all available encrypted index names stored in CyborgDB.
//
// This function calls the `/v1/indexes/list` endpoint of the CyborgDB API, which returns
// a list of index names that have been previously created in the database.
//
// Parameters:
//   - ctx: Context used to control request cancellation, timeouts, and logging.
//
// Returns:
//   - A slice of strings, where each string is the name of an existing encrypted index.
//   - An error if the request fails or the response is malformed.
func (c *Client) ListIndexes(ctx context.Context) ([]string, error) {
	// Call the OpenAPI-generated method
	resp, _, err := c.apiClient.DefaultAPI.ListIndexes(ctx).Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to list indexes: %w", err)
	}

	// Return the actual list of strings from the response
	return resp.Indexes, nil
}

// CreateIndex creates a new encrypted vector index in CyborgDB.
//
// This method creates a new index with the specified configuration and encryption key.
// The index will be empty after creation and ready for vector upserts and queries.
//
// Parameters:
//   - ctx: Context used for cancellation, deadlines, and logging.
//   - indexName: A string that uniquely identifies the index to be created.
//   - indexKey: A 32-byte key used to encrypt the index. Must be exactly 32 bytes in length.
//   - indexModel: A concrete implementation of the IndexModel interface, describing index configuration.
//   - embeddingModel: An optional string pointer specifying the name of the embedding model to associate.
//
// Returns:
//   - A pointer to an EncryptedIndex struct for performing operations on the created index.
//   - An error if validation fails or the API call encounters an issue.
func (c *Client) CreateIndex(
	ctx context.Context,
	indexName string,
	indexKey []byte,
	indexModel IndexModel,
	embeddingModel *string,
) (*EncryptedIndex, error) {
	// Validate that the provided indexKey is exactly 32 bytes.
	// This length is required for AES-256 encryption.
	if len(indexKey) != 32 {
		return nil, fmt.Errorf("index key must be exactly 32 bytes, got %d", len(indexKey))
	}

	// Convert the binary indexKey to a hexadecimal string
	// because the API expects the key in hex format.
	keyHex := hex.EncodeToString(indexKey)

	// Convert the generic IndexModel interface to a strongly typed *IndexConfig,
	// which contains concrete index parameters (e.g., type, dimension, PQ settings).
	indexCfg, err := ConvertToIndexConfig(indexModel)
	if err != nil {
		return nil, fmt.Errorf("failed to convert index model: %w", err)
	}

	// Construct the request payload for the API call.
	createReq := CreateIndexRequest{
		IndexName:      indexName,
		IndexKey:       keyHex,
		IndexConfig:    indexCfg,
		EmbeddingModel: embeddingModel,
	}

	// Send the CreateIndex request using the low-level API client.
	// If the API call fails (non-2xx or transport error), capture and return the error.
	_, _, err = c.apiClient.DefaultAPI.CreateIndex(ctx).
		CreateIndexRequest(createReq).
		Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to create index: %w", err)
	}

	// Construct and return a high-level EncryptedIndex object containing
	// the index name, type, and configuration used in the request.
	// The trained field is initialized to false since new indexes are untrained.
	return &EncryptedIndex{
		indexName: &indexName,
		indexKey:  keyHex,
		indexType: &createReq.IndexConfig.IndexType,
		config:    &createReq.IndexConfig,
		client:    c,
		trained:   false, // New indexes start untrained
	}, nil
}

// GetHealth checks the health status of the CyborgDB service.
//
// This function makes a call to the `/v1/health` endpoint of the CyborgDB API,
// which is typically used for readiness and liveness checks. It can help determine
// if the backend service is reachable and operational.
//
// Parameters:
//   - ctx: Context for request scoping, cancellation, timeout, and logging.
//
// Returns:
//   - A pointer to a HealthResponse object containing the health status details from the server.
//   - An error if the request fails or if the health check endpoint returns a non-success status.
func (c *Client) GetHealth(ctx context.Context) (*HealthResponse, error) {
	// Execute the health check request via the low-level API client.
	// The response body is automatically deserialized into a HealthResponse struct.
	health, _, err := c.apiClient.DefaultAPI.GetHealth(ctx).Execute()
	if err != nil {
		// Wrap and return any error encountered, e.g. HTTP failure, timeout, network issues, etc.
		return nil, fmt.Errorf("health check failed: %w", err)
	}

	// On success, return the parsed HealthResponse struct.
	return health, nil
}

