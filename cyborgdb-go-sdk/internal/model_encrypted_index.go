/*
CyborgDB API

CyborgDB is a secure, encrypted vector database that allows you to store and query high-dimensional vectors with end-to-end encryption. This OpenAPI specification describes the REST interface used by the Go SDK client to perform operations such as indexing, querying, and health checks. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package internal

import (
	"context"
	"encoding/json"
	"fmt"
)

// checks if the EncryptedIndex type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &EncryptedIndex{}

// EncryptedIndex represents an encrypted vector index in CyborgDB.
// It provides a secure way to store and query high-dimensional vectors with end-to-end encryption.
// The index maintains references to the index name, encryption key, type, configuration, and client connection.
type EncryptedIndex struct {
    indexName *string      `json:"index_name,omitempty"`
    indexKey  string       `json:"-"`
    indexType *string      `json:"index_type,omitempty"`
    config    *IndexConfig `json:"config,omitempty"`
    client    *Client      `json:"-"`
    trained   bool         `json:"-"`
}

// NewEncryptedIndex creates and returns a new EncryptedIndex instance with default values.
// This function initializes an empty EncryptedIndex struct.
//
// Returns:
//   - *EncryptedIndex: A pointer to the newly created EncryptedIndex instance
func NewEncryptedIndex() *EncryptedIndex {
	this := EncryptedIndex{}
	return &this
}

// NewEncryptedIndexWithDefaults creates and returns a new EncryptedIndex instance with default values.
// This function is identical to NewEncryptedIndex() and exists for API consistency.
//
// Returns:
//   - *EncryptedIndex: A pointer to the newly created EncryptedIndex instance
func NewEncryptedIndexWithDefaults() *EncryptedIndex {
	this := EncryptedIndex{}
	return &this
}

// GetIndexName retrieves the name of the encrypted index.
// If the index name is not set, it returns an empty string.
//
// Returns:
//   - string: The index name, or empty string if not set
func (o *EncryptedIndex) GetIndexName() string {
	if o == nil || IsNil(o.indexName) {
		var ret string
		return ret
	}
	return *o.indexName
}

// GetIndexNameOk retrieves the index name and a boolean indicating if the value was set.
// This method is useful when you need to distinguish between an empty string and an unset value.
//
// Returns:
//   - *string: Pointer to the index name if set, nil otherwise
//   - bool: true if the index name was set, false otherwise
func (o *EncryptedIndex) getIndexNameOk() (*string, bool) {
	if o == nil || IsNil(o.indexName) {
		return nil, false
	}
	return o.indexName, true
}

// HasIndexName checks whether the index name field has been set.
//
// Returns:
//   - bool: true if the index name is set, false otherwise
func (o *EncryptedIndex) hasIndexName() bool {
	if o != nil && !IsNil(o.indexName) {
		return true
	}
	return false
}

// SetIndexName assigns a new index name to the EncryptedIndex.
// The provided string is stored as a pointer internally.
//
// Parameters:
//   - v: The new index name to set
func (o *EncryptedIndex) setIndexName(v string) {
	o.indexName = &v
}

// GetIndexType retrieves the type of the encrypted index (e.g., "ivf", "ivfpq", "ivfflat").
// If the index type is not set, it returns an empty string.
//
// Returns:
//   - string: The index type, or empty string if not set
func (o *EncryptedIndex) GetIndexType() string {
	if o == nil || IsNil(o.indexType) {
		var ret string
		return ret
	}
	return *o.indexType
}

// GetIndexTypeOk retrieves the index type and a boolean indicating if the value was set.
// This method is useful when you need to distinguish between an empty string and an unset value.
//
// Returns:
//   - *string: Pointer to the index type if set, nil otherwise
//   - bool: true if the index type was set, false otherwise
func (o *EncryptedIndex) getIndexTypeOk() (*string, bool) {
	if o == nil || IsNil(o.indexType) {
		return nil, false
	}
	return o.indexType, true
}

// HasIndexType checks whether the index type field has been set.
//
// Returns:
//   - bool: true if the index type is set, false otherwise
func (o *EncryptedIndex) hasIndexType() bool {
	if o != nil && !IsNil(o.indexType) {
		return true
	}
	return false
}

// SetIndexType assigns a new index type to the EncryptedIndex.
// The provided string is stored as a pointer internally.
//
// Parameters:
//   - v: The new index type to set (e.g., "ivf", "ivfpq", "ivfflat")
func (o *EncryptedIndex) setIndexType(v string) {
	o.indexType = &v
}

// GetIndexConfig retrieves the configuration of the encrypted index.
// If the configuration is not set, it returns a zero-value IndexConfig.
//
// Returns:
//   - IndexConfig: The index configuration, or zero value if not set
func (o *EncryptedIndex) GetIndexConfig() IndexConfig {
	if o == nil || IsNil(o.config) {
		var ret IndexConfig
		return ret
	}
	return *o.config
}

// GetConfigOk retrieves the index configuration and a boolean indicating if the value was set.
// This method is useful when you need to distinguish between a zero-value config and an unset value.
//
// Returns:
//   - *IndexConfig: Pointer to the index configuration if set, nil otherwise
//   - bool: true if the configuration was set, false otherwise
func (o *EncryptedIndex) getConfigOk() (*IndexConfig, bool) {
	if o == nil || IsNil(o.config) {
		return nil, false
	}
	return o.config, true
}

// HasConfig checks whether the index configuration field has been set.
//
// Returns:
//   - bool: true if the configuration is set, false otherwise
func (o *EncryptedIndex) hasConfig() bool {
	if o != nil && !IsNil(o.config) {
		return true
	}
	return false
}

// SetConfig assigns a new configuration to the EncryptedIndex.
// The provided IndexConfig is stored as a pointer internally.
//
// Parameters:
//   - v: The new index configuration to set
func (o *EncryptedIndex) setConfig(v IndexConfig) {
	o.config = &v
}

// MarshalJSON converts the EncryptedIndex to JSON format.
// Note that sensitive fields like IndexKey and client are excluded from serialization.
//
// Returns:
//   - []byte: The JSON representation of the EncryptedIndex
//   - error: Any error that occurred during marshaling
func (o EncryptedIndex) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

// ToMap converts the EncryptedIndex to a map representation suitable for JSON serialization.
// Sensitive fields like IndexKey and client are excluded for security reasons.
//
// Returns:
//   - map[string]interface{}: A map containing the serializable fields
//   - error: Any error that occurred during conversion (currently always nil)
func (o EncryptedIndex) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.indexName) {
		toSerialize["index_name"] = o.indexName
	}
	if !IsNil(o.indexType) {
		toSerialize["index_type"] = o.indexType
	}
	if !IsNil(o.config) {
		toSerialize["config"] = o.config
	}
	return toSerialize, nil
}

// NullableEncryptedIndex is a wrapper that allows EncryptedIndex to be nullable.
// It tracks whether the value has been explicitly set, which is useful for API serialization.
type NullableEncryptedIndex struct {
	value *EncryptedIndex
	isSet bool
}

// Get retrieves the underlying EncryptedIndex value.
//
// Returns:
//   - *EncryptedIndex: The wrapped EncryptedIndex value, or nil if not set
func (v NullableEncryptedIndex) Get() *EncryptedIndex {
	return v.value
}

// Set assigns a new EncryptedIndex value and marks it as set.
//
// Parameters:
//   - val: The EncryptedIndex value to set
func (v *NullableEncryptedIndex) Set(val *EncryptedIndex) {
	v.value = val
	v.isSet = true
}

// IsSet checks whether a value has been explicitly set.
//
// Returns:
//   - bool: true if a value has been set, false otherwise
func (v NullableEncryptedIndex) IsSet() bool {
	return v.isSet
}

// Unset clears the value and marks it as not set.
func (v *NullableEncryptedIndex) Unset() {
	v.value = nil
	v.isSet = false
}

// NewNullableEncryptedIndex creates a new NullableEncryptedIndex with the given value.
//
// Parameters:
//   - val: The EncryptedIndex value to wrap
//
// Returns:
//   - *NullableEncryptedIndex: A new NullableEncryptedIndex instance
func NewNullableEncryptedIndex(val *EncryptedIndex) *NullableEncryptedIndex {
	return &NullableEncryptedIndex{value: val, isSet: true}
}

// MarshalJSON converts the NullableEncryptedIndex to JSON format.
//
// Returns:
//   - []byte: The JSON representation of the wrapped value
//   - error: Any error that occurred during marshaling
func (v NullableEncryptedIndex) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

// UnmarshalJSON deserializes JSON data into the NullableEncryptedIndex.
//
// Parameters:
//   - src: The JSON data to unmarshal
//
// Returns:
//   - error: Any error that occurred during unmarshaling
func (v *NullableEncryptedIndex) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

// ============================================================================
// METHODS
// ============================================================================

// Upsert adds or updates vectors in the encrypted index.
// This operation will insert new vectors or update existing ones based on their IDs.
// All vectors are encrypted before being stored in the index.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle (timeouts, cancellation, etc.)
//   - items: Slice of VectorItem structs containing the vectors and metadata to upsert
//
// Returns:
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) Upsert(ctx context.Context, items []VectorItem) error {
	if e.client == nil {
		return fmt.Errorf("cannot upsert vectors: client reference is nil")
	}
	if e.indexName == nil || *e.indexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.indexKey == "" {
		return fmt.Errorf("index key is required")
	}

	// Map user-facing VectorItems to API VectorItems
	apiItems := make([]VectorItem, len(items))
	for i, item := range items {
		apiItem := VectorItem{
			Id:       item.Id,
			Vector:   item.Vector,
			Metadata: item.Metadata,
		}
		if item.Contents != nil {
			apiItem.Contents = item.Contents
		}
		apiItems[i] = apiItem
	}

	// Construct request with ALL required fields
	upsertRequest := UpsertRequest{
		IndexKey:  e.indexKey,
		IndexName: *e.indexName,
		Items:     apiItems,
	}

	// Call with XIndexKey header (keeping for compatibility with current API client)
	_, err := e.client.apiClient.DefaultAPI.
		UpsertVectors(ctx, *e.indexName).
		XIndexKey(e.indexKey).
		UpsertRequest(upsertRequest).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to upsert vectors: %w", err)
	}
	return nil
}

// DeleteIndex permanently removes the entire encrypted index from the CyborgDB service.
// This operation is irreversible and will delete all vectors and metadata associated with the index.
// Use with caution as this cannot be undone.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle (timeouts, cancellation, etc.)
//
// Returns:
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) DeleteIndex(ctx context.Context) error {
	if e.client == nil {
		return fmt.Errorf("cannot delete index: client reference is nil")
	}
	if e.indexName == nil || *e.indexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.indexKey == "" {
		return fmt.Errorf("index key is required")
	}
	if len(e.indexKey) != 64 {
		return fmt.Errorf("index key must be 64-character hex string (32 bytes), got %d", len(e.indexKey))
	}

	// Call the low-level API
	_, err := e.client.apiClient.DefaultAPI.
		DeleteIndex(ctx, *e.indexName).
		XIndexKey(e.indexKey).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to delete index '%s': %w", *e.indexName, err)
	}

	return nil
}

// Train optimizes the encrypted index for better search performance using machine learning techniques.
// Training is typically performed after upserting a significant number of vectors and improves
// query speed and accuracy. The training process uses clustering algorithms to organize vectors
// for more efficient similarity searches.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle (timeouts, cancellation, etc.)
//   - batchSize: Number of vectors to process in each training batch (affects memory usage)
//   - maxIters: Maximum number of training iterations to perform
//   - tolerance: Convergence tolerance for training (smaller values = more precise training)
//
// Returns:
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) Train(ctx context.Context, batchSize int32, maxIters int32, tolerance float64) error {
	if e.client == nil {
		return fmt.Errorf("cannot train index: client reference is nil")
	}
	if e.indexName == nil || *e.indexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.indexKey == "" {
		return fmt.Errorf("index key is required")
	}
	if len(e.indexKey) != 64 {
		return fmt.Errorf("index key must be 64-character hex string (32 bytes), got %d", len(e.indexKey))
	}

	// Prepare the train request
	trainReq := TrainRequest{
		IndexName: *e.indexName,
		IndexKey:  e.indexKey,
		BatchSize: &batchSize,
		MaxIters:  &maxIters,
		Tolerance: &tolerance,
	}

	// Call the low-level API
	_, err := e.client.apiClient.DefaultAPI.
		TrainIndex(ctx, *e.indexName).
		XIndexKey(e.indexKey).
		TrainRequest(trainReq).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to train index '%s': %w", *e.indexName, err)
	}

	return nil
}
// Query searches for the nearest neighbors to the given query vector(s) in the encrypted index.
// This method performs similarity search using the specified distance metric and returns
// the most similar vectors along with their distances and metadata.
//
// This method supports multiple calling patterns:
// 1. Direct parameters: Query(ctx, queryVectors, topK, nProbes, greedy, filters, include)
// 2. QueryRequest struct: Query(ctx, queryRequest)
// 3. BatchQueryRequest struct: Query(ctx, batchQueryRequest)
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle (timeouts, cancellation, etc.)
//   - args: Variable arguments supporting multiple patterns:
//     * (queryVectors, topK, nProbes, greedy, filters, include) - Direct parameter style
//     * (QueryRequest) - Single query request struct
//     * (BatchQueryRequest) - Batch query request struct
//
// Returns:
//   - *QueryResponse: Contains the search results with nearest neighbors, distances, and metadata
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) Query(ctx context.Context, args ...interface{}) (*QueryResponse, error) {
	if e.client == nil {
		return nil, fmt.Errorf("cannot query index: client reference is nil")
	}
	if e.indexName == nil || *e.indexName == "" {
		return nil, fmt.Errorf("index name is required")
	}
	if e.indexKey == "" {
		return nil, fmt.Errorf("index key is required")
	}

	if len(args) == 0 {
		return nil, fmt.Errorf("at least one argument is required")
	}

	// Convert the binary indexKey to hex (matching TypeScript: Buffer.from(this.indexKey).toString('hex'))
	keyHex := e.indexKey

	// Handle different argument patterns
	switch req := args[0].(type) {
	case *QueryRequest:
		// Convert QueryRequest to BatchQueryRequest (like TypeScript does)
		return e.executeUnifiedQuery(ctx, keyHex, convertQueryRequestToBatch(req))
	case QueryRequest:
		return e.executeUnifiedQuery(ctx, keyHex, convertQueryRequestToBatch(&req))
	case *BatchQueryRequest:
		return e.executeUnifiedQuery(ctx, keyHex, req)
	case BatchQueryRequest:
		return e.executeUnifiedQuery(ctx, keyHex, &req)
	default:
		// Handle direct parameter style - convert to BatchQueryRequest
		return e.executeDirectQueryAsBatch(ctx, keyHex, args...)
	}
}
// convertQueryRequestToBatch converts a QueryRequest to BatchQueryRequest format.
// This helper function ensures consistency with the TypeScript SDK which always
// uses batch format internally, even for single vector queries.
//
// Parameters:
//   - req: The QueryRequest to convert
//
// Returns:
//   - *BatchQueryRequest: The converted batch request
func convertQueryRequestToBatch(req *QueryRequest) *BatchQueryRequest {
	batch := &BatchQueryRequest{
		IndexName: req.IndexName,
		IndexKey:  req.IndexKey,
		Filters:   req.Filters,
		Include:   req.Include,
	}

	// Convert single vector to batch format
	if req.QueryVector != nil && len(req.QueryVector) > 0 {
		batch.QueryVectors = [][]float32{req.QueryVector}
	} else if req.QueryVectors != nil && len(req.QueryVectors) > 0 {
		batch.QueryVectors = req.QueryVectors
	}

	// Handle TopK, NProbes, Greedy - convert from direct values to pointers
	batch.TopK = &req.TopK
	batch.NProbes = &req.NProbes
	if req.Greedy != nil {
		batch.Greedy = req.Greedy
	}

	return batch
}

// executeUnifiedQuery executes a query using the BatchQueryRequest format.
// This is the core query execution method that all other query patterns ultimately use.
// It matches the TypeScript SDK behavior of always using batch requests internally.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle
//   - keyHex: The index encryption key in hexadecimal format
//   - req: The BatchQueryRequest containing query parameters
//
// Returns:
//   - *QueryResponse: The query results
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) executeUnifiedQuery(ctx context.Context, keyHex string, req *BatchQueryRequest) (*QueryResponse, error) {
	// Validate input
	if req.QueryVectors == nil || len(req.QueryVectors) == 0 {
		return nil, fmt.Errorf("QueryVectors is required")
	}

	// Ensure index name and key are set
	req.IndexName = *e.indexName
	req.IndexKey = keyHex

	// Set defaults (matching TypeScript defaults)
	if req.TopK == nil {
		defaultTopK := int32(100)
		req.TopK = &defaultTopK
	}
	if req.NProbes == nil {
		defaultNProbes := int32(1)
		req.NProbes = &defaultNProbes
	}
	if req.Greedy == nil {
		defaultGreedy := false
		req.Greedy = &defaultGreedy
	}
	if req.Include == nil || len(req.Include) == 0 {
		req.Include = []string{"distance", "metadata"}
	}

	// IMPORTANT: Always use BatchQueryRequest method like TypeScript does
	resp, _, err := e.client.apiClient.DefaultAPI.
		QueryVectors(ctx).
		BatchQueryRequest(*req).
		Execute()

	if err != nil {
		return nil, fmt.Errorf("failed to query index '%s': %w", *e.indexName, err)
	}

	return resp, nil
}

// executeQueryRequest handles QueryRequest struct by converting it to BatchQueryRequest.
// This method is kept for backward compatibility but internally uses the unified batch approach.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle
//   - req: The QueryRequest to execute
//
// Returns:
//   - *QueryResponse: The query results
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) executeQueryRequest(ctx context.Context, req *QueryRequest) (*QueryResponse, error) {
	// Validate that we have either QueryVector, QueryVectors, or QueryContents
	hasQueryVector := req.QueryVector != nil && len(req.QueryVector) > 0
	hasQueryVectors := req.QueryVectors != nil && len(req.QueryVectors) > 0
	hasQueryContents := req.QueryContents != nil && *req.QueryContents != ""

	if !hasQueryVector && !hasQueryVectors && !hasQueryContents {
		return nil, fmt.Errorf("QueryRequest must have QueryVector, QueryVectors, or QueryContents")
	}

	// Set default values if not provided
	if req.TopK == 0 {
		req.TopK = 100
	}
	if req.NProbes == 0 {
		req.NProbes = 1
	}
	if req.Include == nil || len(req.Include) == 0 {
		req.Include = []string{"distance", "metadata"}
	}

	// Ensure index name and key are set from the EncryptedIndex
	req.IndexName = *e.indexName
	req.IndexKey = e.indexKey

	// Execute the query
	resp, _, err := e.client.apiClient.DefaultAPI.
		QueryVectors(ctx).
		QueryRequest(*req).
		Execute()

	if err != nil {
		return nil, fmt.Errorf("failed to query index '%s': %w", *e.indexName, err)
	}

	return resp, nil
}

// executeDirectQueryAsBatch handles direct parameter queries by converting them to BatchQueryRequest.
// This method parses the variable arguments and creates a BatchQueryRequest, matching
// the TypeScript SDK behavior.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle
//   - keyHex: The index encryption key in hexadecimal format
//   - args: Variable arguments containing queryVectors, topK, nProbes, greedy, filters, include
//
// Returns:
//   - *QueryResponse: The query results
//   - error: nil on success, or an error describing what went wrong
func (e *EncryptedIndex) executeDirectQueryAsBatch(ctx context.Context, keyHex string, args ...interface{}) (*QueryResponse, error) {
	if len(args) < 1 {
		return nil, fmt.Errorf("at least queryVectors argument is required")
	}

	// Parse arguments with defaults (matching TypeScript)
	var inputVectors interface{} = args[0]
	var topK int32 = 100
	var nProbes int32 = 1
	var greedy bool = false
	var filters map[string]interface{}
	var include []string = []string{"distance", "metadata"}

	// Extract optional arguments
	if len(args) > 1 {
		if v, ok := args[1].(int32); ok {
			topK = v
		} else if v, ok := args[1].(int); ok {
			topK = int32(v)
		}
	}

	if len(args) > 2 {
		if v, ok := args[2].(int32); ok {
			nProbes = v
		} else if v, ok := args[2].(int); ok {
			nProbes = int32(v)
		}
	}

	if len(args) > 3 {
		if v, ok := args[3].(bool); ok {
			greedy = v
		}
	}

	if len(args) > 4 {
		if v, ok := args[4].(map[string]interface{}); ok {
			filters = v
		}
	}

	if len(args) > 5 {
		if v, ok := args[5].([]string); ok {
			include = v
		}
	}

	// Convert input to batch format (exactly like TypeScript does)
	var queryVectors [][]float32

	switch v := inputVectors.(type) {
	case []float32:
		// Single vector - wrap in array (like TypeScript: [inputVectors as number[]])
		queryVectors = [][]float32{v}
	case [][]float32:
		// Already batch format
		queryVectors = v
	default:
		return nil, fmt.Errorf("queryVectors must be []float32 or [][]float32, got %T", inputVectors)
	}

	// Create BatchQueryRequest (matching TypeScript structure)
	batchRequest := &BatchQueryRequest{
		IndexName:    *e.indexName,
		IndexKey:     keyHex,
		QueryVectors: queryVectors,
		TopK:         &topK,
		NProbes:      &nProbes,
		Greedy:       &greedy,
		Filters:      filters,
		Include:      include,
	}

	return e.executeUnifiedQuery(ctx, keyHex, batchRequest)
}

// executeDirectQuery handles the direct parameter style (LEGACY).
// This method exists for backward compatibility but is no longer the primary execution path.
// New implementations should use executeDirectQueryAsBatch which maintains consistency
// with the TypeScript SDK.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle
//   - args: Variable arguments containing query parameters
//
// Returns:
//   - *QueryResponse: The query results
//   - error: nil on success, or an error describing what went wrong
//
// Deprecated: Use executeDirectQueryAsBatch instead for better consistency with TypeScript SDK.
func (e *EncryptedIndex) executeBatchQueryRequest(ctx context.Context, req *BatchQueryRequest) (*QueryResponse, error) {
	// Validate that we have QueryVectors
	if req.QueryVectors == nil || len(req.QueryVectors) == 0 {
		return nil, fmt.Errorf("BatchQueryRequest must have QueryVectors")
	}

	// Set default values if not provided
	if req.TopK == nil {
		defaultTopK := int32(100)
		req.TopK = &defaultTopK
	}
	if req.NProbes == nil {
		defaultNProbes := int32(1)
		req.NProbes = &defaultNProbes
	}
	if req.Greedy == nil {
		defaultGreedy := false
		req.Greedy = &defaultGreedy
	}
	if req.Include == nil || len(req.Include) == 0 {
		req.Include = []string{"distance", "metadata"}
	}

	// Ensure index name and key are set from the EncryptedIndex
	req.IndexName = *e.indexName
	req.IndexKey = e.indexKey

	// Execute the batch query (assuming you have a BatchQueryVectors API endpoint)
	resp, _, err := e.client.apiClient.DefaultAPI.
		QueryVectors(ctx).
		BatchQueryRequest(*req).
		Execute()

	if err != nil {
		return nil, fmt.Errorf("failed to batch query index '%s': %w", *e.indexName, err)
	}

	return resp, nil
}

// executeDirectQuery handles the direct parameter style
func (e *EncryptedIndex) executeDirectQuery(ctx context.Context, args ...interface{}) (*QueryResponse, error) {
	if len(args) < 1 {
		return nil, fmt.Errorf("at least queryVectors argument is required")
	}

	// Parse arguments with defaults
	var queryVectors interface{}
	var topK int32 = 100
	var nProbes int32 = 1
	var greedy bool = false
	var filters map[string]interface{}
	var include []string

	// Extract arguments
	queryVectors = args[0]

	if len(args) > 1 {
		if v, ok := args[1].(int32); ok {
			topK = v
		} else if v, ok := args[1].(int); ok {
			topK = int32(v)
		}
	}

	if len(args) > 2 {
		if v, ok := args[2].(int32); ok {
			nProbes = v
		} else if v, ok := args[2].(int); ok {
			nProbes = int32(v)
		}
	}

	if len(args) > 3 {
		if v, ok := args[3].(bool); ok {
			greedy = v
		}
	}

	if len(args) > 4 {
		if v, ok := args[4].(map[string]interface{}); ok {
			filters = v
		}
	}

	if len(args) > 5 {
		if v, ok := args[5].([]string); ok {
			include = v
		}
	}

	// Set default include if not provided
	if include == nil || len(include) == 0 {
		include = []string{"distance", "metadata"}
	}

	// Handle single vector vs batch of vectors
	var vectors [][]float32
	switch v := queryVectors.(type) {
	case []float32:
		// Single vector - wrap in array
		vectors = [][]float32{v}
	case [][]float32:
		// Batch of vectors
		vectors = v
	default:
		return nil, fmt.Errorf("queryVectors must be []float32 or [][]float32")
	}

	// Determine if this should be a single query or batch query based on input
	if len(vectors) == 1 {
		// Use QueryRequest for single vector
		queryRequest := QueryRequest{
			IndexName:    *e.indexName,
			IndexKey:     e.indexKey,
			QueryVector:  vectors[0], // Use single vector field
			TopK:         topK,
			NProbes:      nProbes,
			Greedy:       &greedy,
			Filters:      filters,
			Include:      include,
		}

		return e.executeQueryRequest(ctx, &queryRequest)
	} else {
		// Use BatchQueryRequest for multiple vectors
		batchRequest := BatchQueryRequest{
			IndexName:    *e.indexName,
			IndexKey:     e.indexKey,
			QueryVectors: vectors,
			TopK:         &topK,
			NProbes:      &nProbes,
			Greedy:       &greedy,
			Filters:      filters,
			Include:      include,
		}

		return e.executeBatchQueryRequest(ctx, &batchRequest)
	}
}

// Delete removes specific vectors from the encrypted index using their unique identifiers.
// This operation permanently deletes the specified vectors and their associated metadata.
// The vectors cannot be recovered after deletion.
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle (timeouts, cancellation, etc.)
//   - ids: Slice of string IDs identifying the vectors to delete
//
// Returns:
//   - error: nil on success, or an error describing what went wrong
//
// Example:
//   idsToDelete := []string{"vec1", "vec2", "vec3"}
//   err := index.Delete(ctx, idsToDelete)
//   if err != nil {
//       log.Printf("Failed to delete vectors: %v", err)
//   }
//
// Note: Deleting non-existent IDs will not cause an error. The operation will
// succeed and only existing vectors will be removed.
func (e *EncryptedIndex) Delete(ctx context.Context, ids []string) error {
	if e.client == nil {
		return fmt.Errorf("cannot delete vectors: client reference is nil")
	}
	if e.indexName == nil || *e.indexName == "" {
		return fmt.Errorf("index name is required")
	}
	if e.indexKey == "" {
		return fmt.Errorf("index key is required")
	}
	if len(e.indexKey) != 64 {
		return fmt.Errorf("index key must be 64-character hex string (32 bytes), got %d", len(e.indexKey))
	}
	if len(ids) == 0 {
		return fmt.Errorf("at least one vector ID must be provided for deletion")
	}

	// Construct the delete request body
	deleteReq := DeleteRequest{
		IndexName: *e.indexName,
		IndexKey:  e.indexKey,
		Ids:       ids,
	}

	// Call the low-level API
	_, err := e.client.apiClient.DefaultAPI.
		DeleteVectors(ctx, *e.indexName).
		XIndexKey(e.indexKey).
		DeleteRequest(deleteReq).
		Execute()

	if err != nil {
		return fmt.Errorf("failed to delete vectors from index '%s': %w", *e.indexName, err)
	}

	return nil
}

// Get retrieves specific vectors from the encrypted index using their unique identifiers.
// This method allows you to fetch vectors by their IDs and specify which fields to include
// in the response (vectors, metadata, contents).
//
// Parameters:
//   - ctx: Context for controlling the request lifecycle (timeouts, cancellation, etc.)
//   - ids: Slice of string IDs identifying the vectors to retrieve
//   - include: Fields to include in the response (e.g., ["vector", "metadata", "contents"])
//
// Returns:
//   - *GetResponse: Response containing retrieved vectors with requested fields
//   - error: nil on success, or an error describing what went wrong
//
// Note: If a requested ID does not exist, it will not be included in the results.
// The returned slice may be shorter than the requested IDs slice.
// For trained IVFPQ indexes, retrieved vectors may be compressed and have different
// dimensions than the original vectors.
func (e *EncryptedIndex) Get(ctx context.Context, ids []string, include []string) (*GetResponse, error) {
	if e.client == nil {
		return nil, fmt.Errorf("cannot get vectors: client reference is nil")
	}
	if e.indexName == nil || *e.indexName == "" {
		return nil, fmt.Errorf("index name is required")
	}
	if e.indexKey == "" {
		return nil, fmt.Errorf("index key is required")
	}
	if len(ids) == 0 {
		return nil, fmt.Errorf("at least one vector ID must be provided for retrieval")
	}

	// Prepare the API request
	resp, _, err := e.client.apiClient.DefaultAPI.
		GetVectors(ctx, *e.indexName).
		XIndexKey(e.indexKey).
		Ids(ids).
		Include(include).
		Execute()

	if err != nil {
		return nil, fmt.Errorf("failed to retrieve vectors from index '%s': %w", *e.indexName, err)
	}

	return resp, nil
}
// IsTrained returns whether the index has been trained.
// Training optimizes the index for better search performance and is typically
// performed after upserting a significant number of vectors.
//
// Returns:
//   - bool: true if the index has been trained, false otherwise
//
// Note: The trained state is tracked locally and may not reflect the actual
// server-side state if the index was trained outside of this client instance.
func (e *EncryptedIndex) IsTrained() bool {
    return e.trained  // You'll need to add this field
}