package internal

import (
	"context"
	"crypto/tls"
	"encoding/hex"
	"fmt"
	"net/http"
	"net/url"
)

// Client is a thin wrapper over the OpenAPI-generated API client.
// It exposes ergonomic methods like CreateIndex, ListIndexes, LoadIndex, and GetHealth,
// and stores client-wide settings (base URL, API key).
type Client struct {
	apiClient *APIClient // Autogenerated low-level client
	baseURL   string
	apiKey    string
}

// NewClient initializes an internal client with TLS and header configuration.
//
// Parameters:
//   - baseURL: Base API endpoint, e.g. "https://api.cyborgdb.com"
//   - apiKey: Sent as X-API-Key header (optional but required for authenticated routes)
//   - verifySSL: If false, disables TLS cert verification (useful for local dev)
//
// Returns:
//   - *Client or error
func NewClient(baseURL, apiKey string, verifySSL bool) (*Client, error) {
	parsedURL, err := url.Parse(baseURL)
	if err != nil {
		return nil, fmt.Errorf("invalid base URL: %w", err)
	}

	if !verifySSL && (parsedURL.Hostname() == "localhost" || parsedURL.Hostname() == "127.0.0.1") {
		fmt.Println("SSL verification is disabled for localhost (development mode)")
	}

	cfg := NewConfiguration()
	cfg.Scheme = parsedURL.Scheme
	cfg.Host = parsedURL.Host

	// Ensure /v1 is used for server URLs.
	cfg.Servers = []ServerConfiguration{
		{
			URL:         fmt.Sprintf("%s://%s/v1", parsedURL.Scheme, parsedURL.Host),
			Description: "CyborgDB API with /v1",
		},
	}

	if apiKey != "" {
		cfg.AddDefaultHeader("X-API-Key", apiKey)
	}

	// Allow disabling verification for local development.
	cfg.HTTPClient = &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: !verifySSL},
		},
	}

	apiClient := NewAPIClient(cfg)
	return &Client{
		apiClient: apiClient,
		baseURL:   baseURL,
		apiKey:    apiKey,
	}, nil
}

// ListIndexes returns all encrypted index names.
//
// Calls the /v1/indexes/list endpoint and returns the names only.
//
// Parameters:
//   - ctx: Context for cancellation/timeouts
//
// Returns:
//   - []string: Index names
//   - error: Any error encountered
func (c *Client) ListIndexes(ctx context.Context) ([]string, error) {
	resp, _, err := c.apiClient.DefaultAPI.ListIndexes(ctx).Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to list indexes: %w", err)
	}
	return resp.Indexes, nil
}

// CreateIndex creates a new encrypted index using a single request struct.
//
// Parameters:
//   - ctx: Context for cancellation/timeouts
//   - req: CreateIndexRequest containing index name, hex-encoded key (64 chars),
//          optional index config, optional metric, and optional embeddingModel.
//
// Returns:
//   - *EncryptedIndex: Handle to the created index
//   - error: Any error encountered
//
// Notes:
//   - req.IndexKey must hex-decode to exactly 32 bytes.
//   - req.IndexConfig is optional; server defaults may apply.
//   - req.Metric (if present) is forwarded as-is.
func (c *Client) CreateIndex(
	ctx context.Context,
	req *CreateIndexRequest,
) (*EncryptedIndex, error) {
	if req == nil {
		return nil, fmt.Errorf("create index request cannot be nil")
	}
	if req.IndexName == "" {
		return nil, fmt.Errorf("index name is required")
	}
	if len(req.IndexKey) == 0 {
		return nil, fmt.Errorf("index key (hex) is required")
	}
	keyBytes, err := hex.DecodeString(req.IndexKey)
	if err != nil {
		return nil, fmt.Errorf("index key must be hex: %w", err)
	}
	if len(keyBytes) != 32 {
		return nil, fmt.Errorf("index key must be 32 bytes after hex decoding, got %d", len(keyBytes))
	}

	_, _, err = c.apiClient.DefaultAPI.CreateIndex(ctx).
		CreateIndexRequest(*req).
		Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to create index: %w", err)
	}

	// Build the local handle from the request we sent.
	idx := &EncryptedIndex{
		indexName: &req.IndexName,
		indexKey:  req.IndexKey, // already hex
	}
	if req.IndexConfig.IndexType != "" {
		idx.indexType = &req.IndexConfig.IndexType
	}
	// Keep config pointer if provided; zero-value is fine if omitted
	cfg := req.IndexConfig
	idx.config = &cfg

	// Newly created index is untrained.
	idx.trained = false
	idx.client = c

	return idx, nil
}

// GetHealth probes the /v1/health endpoint for service status.
//
// Parameters:
//   - ctx: Context for cancellation/timeouts
//
// Returns:
//   - *HealthResponse with server status
//   - error: Any error encountered
func (c *Client) GetHealth(ctx context.Context) (*HealthResponse, error) {
	health, _, err := c.apiClient.DefaultAPI.GetHealth(ctx).Execute()
	if err != nil {
		return nil, fmt.Errorf("health check failed: %w", err)
	}
	return health, nil
}

// LoadIndex loads an existing encrypted index by name and 32-byte key.
//
// Validates the key length, fetches index description from the server,
// and returns a handle initialized for vector operations.
func (c *Client) LoadIndex(ctx context.Context, indexName string, indexKey []byte) (*EncryptedIndex, error) {
	if len(indexKey) != 32 {
		return nil, fmt.Errorf("index key must be exactly 32 bytes, got %d", len(indexKey))
	}

	keyHex := hex.EncodeToString(indexKey)

	describeReq := IndexOperationRequest{
		IndexName: indexName,
		IndexKey:  keyHex,
	}

	indexInfo, _, err := c.apiClient.DefaultAPI.GetIndexInfo(ctx).
		IndexOperationRequest(describeReq).
		Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to get index info: %w", err)
	}

	return &EncryptedIndex{
		indexName: &indexInfo.IndexName,
		indexKey:  keyHex,
		indexType: &indexInfo.IndexType,
		config:    &indexInfo.IndexConfig,
		client:    c,
		trained:   indexInfo.IsTrained,
	}, nil
}
